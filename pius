#!/usr/bin/python

# vim:shiftwidth=2:tabstop=2:expandtab:textwidth=78:softtabstop=2:ai:

#
# This script was made from a shoddy group of shell scripts that tried to make
# this work easier. However, gpg doesn't give the nicest interface for
# automation, and this evolved into a much more complex script.
#
# Wherever possible we use the --*-fd options to gpg for automation rather
# than screenscraping (using pexpect) since it's more resiliant. However,
# until working with gpg-agent is full working the 'interactive' mode (which
# requires pexpect) will remain in the code.
#
# Note that the only way to specify a UID is in --edit-key, without --batch.
#
# Copyright (c) 2009 Phil Dibowitz (phil@ipom.com)
#
#   This program is free software; you can redistribute it and/or
#   modify it under the terms of the GNU General Public License as
#   published by the Free Software Foundation, version 2.
#
# TODO:
#   - Offer the ability encrypt-email these off (maybe, will require mutt)
#   - Handle UIDs without email addresses
#

import getpass
import os
import pexpect
import re
import socket
import subprocess
import sys
import time
from optparse import OptionParser

VERSION = '1.1'
debug_on = False

MODE_INTERACTIVE = 0
MODE_CACHE_PASSPHRASE = 1
MODE_AGENT = 2

DEFAULT_GPG_PATH = '/usr/bin/gpg'
DEFAULT_KEYRING = '~/.gnupg/pubring.gpg'
DEFAULT_TMP_DIR = '/tmp'
DEFAULT_OUT_DIR = '/tmp'

def debug(line):
  if debug_on:
    print 'DEBUG: ', line

class AgentError(Exception):
  pass

class PassphraseError(Exception):
  pass

class uids_signer(object):

  TMP_KEYRING_FILE = 'pius_keyring.asc'

  GPG_PROMPT = '[GNUPG:] GET_LINE keyedit.prompt'
  GPG_ACK = '[GNUPG:] GOT_IT'
  GPG_ALREADY_SIGNED = '[GNUPG:] ALREADY_SIGNED'
  GPG_CONFIRM = '[GNUPG:] GET_BOOL sign_uid.okay'
  GPG_SAVE = '[GNUPG:] GET_BOOL keyedit.save.okay'

  def __init__(self, signer, mode, keyring, gpg_path, tmpdir, outdir,
               encrypt_outfiles, sign_level):
    self.mode = mode
    self.signer = signer
    self.keyring = keyring
    self.passphrase_confirmed = False
    self.gpg = gpg_path
    self.tmpdir = tmpdir
    self.outdir = outdir
    self.encrypt_outfiles = encrypt_outfiles
    self.sign_level = sign_level
    self.tmp_keyring = '%s/%s' % (self.tmpdir, uids_signer.TMP_KEYRING_FILE)

  def cleanup(self):
    self._clean_files([self.tmp_keyring, ('%s~' % self.tmp_keyring)])

  def check_fingerprint(self, key):
    cmd = ('%s --no-default-keyring --keyring %s --fingerprint %s'
           % (self.gpg, self.keyring, key))
    gpg = os.popen(cmd, 'r')
    for line in gpg.readlines():
      if line != '\n':
        print line.strip()
    gpg.close()
    a = raw_input('Have you verified this user/key? (y/n) ')
    print
    if a in ('y', 'Y', 'yes', 'Yes', 'YES'):
      return True;
    return False

  def get_passphrase(self):
    self.passphrase = getpass.getpass('Please enter your PGP passphrase: ')

  def _clean_files(self, list):
    for file in list:
      if os.path.exists(file):
        os.unlink(file)

  def verify_passphrase(self):
    magic_string = 'test1234'
    filename = '%s/pius_tmp' % self.tmpdir
    filename_enc = '%s/pius_tmp.gpg' % self.tmpdir
    filename_dec = '%s/pius_tmp2' % self.tmpdir
    self._clean_files([filename, filename_enc, filename_dec])
    tfile = open(filename, 'w')
    tfile.write(magic_string)
    tfile.close()
    cmd = ('%s --always-trust -q -r %s -e %s'
           % (self.gpg, self.signer, filename))
    debug(cmd)
    gpg = os.popen(cmd, 'r')
    gpg.close()
    cmd = ('%s --passphrase-fd 0 --command-fd 0 --status-fd 1 --batch -q'
           ' --output %s -d %s' % (self.gpg, filename_dec, filename_enc))
    debug(cmd)
    gpg = subprocess.Popen(cmd, shell=True, stdin=subprocess.PIPE,
                           stdout=subprocess.PIPE,
                           stderr=subprocess.PIPE,
                           close_fds=True)

    time.sleep(1)
    debug('Sending passphrase')
    gpg.stdin.write('%s\n' % self.passphrase)
    time.sleep(1)
    os.kill(gpg.pid, 15)

    debug('Waiting for result')
    gpg.wait()
    if not os.path.exists(filename_dec):
      debug('Resulting file %s not found' % filename_dec)
      return False
    tfile = open(filename_dec, 'r')
    line = tfile.readline()
    tfile.close()
    self._clean_files([filename, filename_enc, filename_dec])
    if line == magic_string:
      self.passphrase_confirmed = True
      return True
    debug('File does not contain magic string')
    return False

  def get_uids(self, key):
    cmd = ('%s --command-fd 0 --status-fd 1 --no-tty --no-default-keyring '
           ' --keyring %s --no-options --with-colons --edit-key %s'
           % (self.gpg, self.keyring, key))
    debug(cmd)
    gpg = subprocess.Popen(cmd, shell=True, stdin=subprocess.PIPE,
                           stdout=subprocess.PIPE,
                           stderr=subprocess.PIPE,
                           close_fds=True)

    # We want the indexes to start the indexs at 1 (which is what pgp uses)
    # so we fill the 0th entry.
    uids = ['empty']
    unique_files = {}
    while True:
      line = gpg.stdout.readline().strip()
      if not line:
        debug('breaking, EOF')
        break
      if line == uids_signer.GPG_PROMPT:
        debug('got to command prompt')
        break
      debug('Got a line %s' % line)
      m = re.search('^uid:(.)::::::::[^:]+ <([^:]+)>:.*:$', line.strip())
      if m:
        debug('match')
        status = m.group(1)
        email = m.group(2)
        debug('Got UID %s with status %s' % (email, status))
        filename = re.sub('@', '_at_', email)
        filename = '%s__%s.asc' % (key, filename)
        while filename in unique_files.keys():
          filename = '%s_2' % filename
        debug('got email %s' % email)
        unique_files[filename] = True
        uids.append({'email': email, 'file': filename, 'status': status})
      else:
        debug('else')
        continue

    debug('quitting')
    # sometimes it wants a save here. I don't know why. We can quit and check
    # for a save prompt, and then hit no, but we have to make sure it's still
    # running or we'll hang. It's just easier to issue a 'save' instead of a
    # quit
    gpg.stdin.write('save\n')
    debug('waiting')
    gpg.wait()

    return uids

  def nuke_working_keyring(self):
    os.unlink(self.tmp_keyring)

  def encrypt_signed_uid(self, key, filename):
    path = '%s/%s' % (self.outdir, filename)
    cmd = ('%s -q --no-default-keyring --keyring %s --always-trust -r %s'
           ' -e %s' % (self.gpg, self.tmp_keyring, key, path))
    debug(cmd)
    gpg = os.popen(cmd, 'r')
    gpg.close()

  def _export_key(self, keyring, key, path):
    if os.path.exists(path):
      os.unlink(path)
    cmd = ('%s -q --no-default-keyring --keyring %s --armor'
           ' --output %s --export %s' % (self.gpg, keyring, path, key))
    debug(cmd)
    gpg = os.popen(cmd, 'r')
    gpg.close()

  def export_signed_uid(self, key, filename):
    path = '%s/%s' % (self.outdir, filename)
    debug('exporting %s' % key)
    self._export_key(self.tmp_keyring, key, path)

  def export_clean_key(self, key):
    debug('exporting %s' % key)
    # We have to export our own public key as well
    keys_to_export = '%s %s' % (key, self.signer)
    path = '%s/%s.asc' % (self.tmpdir, key)
    self._export_key(self.keyring, keys_to_export, path)

  def clean_clean_key(self, key):
    path = '%s/%s.asc' % (self.tmpdir, key)
    self._clean_files([path])

  def import_clean_key(self, key):
    path = '%s/%s.asc' % (self.tmpdir, key)
    cmd = ('%s -q --no-default-keyring --keyring %s'
           ' --import %s' % (self.gpg, self.tmp_keyring, path))
    debug(cmd)
    gpg = os.popen(cmd, 'r')
    gpg.close()

  def sign_with_interact(self, gpg): 
    print '  Passing you to gpg for passprhase.'
    print '  Hit ^] after succesfully typing in your passphrase'
    gpg.interact()
    # When we return, we have a Command> prompt that w can't
    # 'expect'... or at least if the user did it right
    print ''

  def sign_with_cache_passphrase(self, gpg):
    # It's worth noting here that the way the 'sign' command works
    # doesn't allow you to catch the 'Invalid passphrase' or even the next
    # 'Command> ' prompt because pexpect seems to get confused by the fact
    # that it erases a line.
    #
    # As such, rather than try to catch a bad passphrase on our furst use of
    # it, we instead very the passphrase upon asking the user for it, and then
    # assume it's good here.
    gpg.expect('Enter passphrase.*')
    debug('Sending passphrase')
    gpg.sendline(self.passphrase)

  #
  # NOTE:
  #    This currently doesn't work with gpg-agent very seemlessly. If you have
  #    an agent on, and you DON'T specify -p, it'll work, but you have to hit
  #    the 'special char' after each sign. If you do use -p, then we never get
  #    a command-prompt and we get confused. I've yet to make htis work.
  #
  def sign_uid_expect(self, key, index):
    cmd = ('%s --no-default-keyring --keyring %s --default-cert-level %s'
           ' --no-ask-cert-level --edit-key %s'
           % (self.gpg, self.tmp_keyring, self.sign_level, key))
    debug(cmd)
    gpg = pexpect.spawn(cmd)
    gpg.setecho(False)
    gpg.expect('Command> ')
    debug('Selecting UID')
    gpg.sendline(str(index))
    gpg.expect('Command> ')
    debug('Running sign subcommand')
    gpg.sendline('sign')
    line = gpg.readline()
    if 'already signed' in line:
      print '  UID already signed'
      return False
    # else it's a blank line...

    gpg.expect(re.compile('Really sign.*'))
    debug('Confirming signing')
    gpg.sendline('y')
    if self.cache_passphrase:
      self.sign_with_cache_passphrase(gpg)
    else:
      self.sign_with_interact(gpg)
    # Unselect this UID
    debug('unselecting uid')
    #gpg.sendline(str(index))
    #gpg.expect('Command> ')
    debug('Saving key')
    gpg.sendline('save')
    #gpg.close()
    return True

  def _gpg_wait_for_string(self, fd, string):
    line = ''
    while line not in (string,):
      debug('Waiting for line')
      line = fd.readline().strip()
      debug('got line %s' % line)

  #
  # This is how we SHOULD be doing it, but I can't make the fd stuff work
  # properly:
  #  * If I use --batch, most things work but I can't specify a UID (it just
  #    ignores it)
  #  * If I don't use --batch it never notices when I send the passphrase.
  #
  def sign_uid(self, key, index):
    agent = ''
    if self.mode == MODE_AGENT:
      agent = '--use-agent'
    # Note that if passphrase-fd is different from command-fd, nothing works.
    cmd = ('%s -q --command-fd 0 --status-fd 1 --no-tty'
           ' --passphrase-fd 0 --no-default-keyring --keyring %s %s'
           ' --default-cert-level %s --no-ask-cert-level --edit-key %s' %
           (self.gpg, self.tmp_keyring, agent, self.sign_level, key))

    debug(cmd)
    gpg = subprocess.Popen(cmd, shell=True, stdin=subprocess.PIPE,
                           stdout=subprocess.PIPE,
                           stderr=subprocess.PIPE,
                           close_fds=True)

    if self.mode == MODE_AGENT:
      # For some reason when using agent an initial enter is needed
      gpg.stdin.write('\n')
    else:
      # For some unidentified reason you must send the passphrase
      # first, not when it asks for it.
      debug('Sending passphrase')
      gpg.stdin.write('%s\n' % self.passphrase)


    debug('Waiting for prompt')
    self._gpg_wait_for_string(gpg.stdout, uids_signer.GPG_PROMPT)
    debug('Selecting UID')
    gpg.stdin.write('%s\n' % str(index))
    debug('Waiting for ack')
    self._gpg_wait_for_string(gpg.stdout, uids_signer.GPG_ACK)

    debug('Running sign subcommand')
    self._gpg_wait_for_string(gpg.stdout, uids_signer.GPG_PROMPT)
    debug('Sending sign command')
    gpg.stdin.write('sign\n')
    self._gpg_wait_for_string(gpg.stdout, uids_signer.GPG_ACK)

    # Either we already signed this, or we can proceed
    line = gpg.stdout.readline()
    debug('Got %s' % line)
    if uids_signer.GPG_ALREADY_SIGNED in line:
      print '  UID already signed'
      gpg.stdin.write('quit\n')
      return False
    elif not uids_signer.GPG_CONFIRM in line:
      print '  ERROR: GnuPG reported an unknown error'
      gpg.stdin.write('quit\n')
      return False
    # else its uids_signer.GPG_CONFIRM...

    debug('Confirming signing')
    gpg.stdin.write('Y\n')
    self._gpg_wait_for_string(gpg.stdout, uids_signer.GPG_ACK)

    #
    # gpg-agent doesn't always work as well as we like. Of the problems:
    #  * It can't always pop up an X window reliably (pinentry problems)
    #  * It doesn't seem able to figure out the best pinetry program
    #    to use in many situations
    #  * Sometimes it silently fails in odd ways
    #
    # So this chunk of code will follow gpg through as many tries as gpg-agent
    # is willing to give and then inform the user of an error and raise an
    # exception.
    #
    # Since we're here, we also handle the highly unlikely case where the
    # verified cached passphrase doesn't work.
    #
    while True:
      line = gpg.stdout.readline()
      debug('Got %s' % line)
      if 'BAD_PASSPHRASE' in line:
        if self.mode == MODE_AGENT:
          line = gpg.stdout.readline()
          debug('Got %s' % line)
          if 'USERID_HINT' in line:
            continue
          print '  ERROR: Agent didn\'t provide passphrase to PGP.'
          raise AgentError
        else:
          print '  ERROR: GPG didn\'t accept the passphrase.'
          raise PassphraseError
      if 'GOOD_PASSPHRASE' in line:
        break

    debug('Saving key')
    self._gpg_wait_for_string(gpg.stdout, uids_signer.GPG_PROMPT)
    gpg.stdin.write('save\n')

    gpg.wait()
    return True

  def sign_all_uids(self, key):
    uids = self.get_uids(key)
    print '  There are %s UIDs on this key to sign' % (len(uids) - 1)
    # From the user key ring make a clean copy
    self.export_clean_key(key)
    # sys.exit(0)
    for index in range(1, len(uids)):
      if uids[index]['status'] == 'r':
        print '  Skipping revoked uid %s' % index
        continue
      print '  Signing UID %s (%s)' % (index, uids[index]['file'])
      # Import it to our working keyring
      self.import_clean_key(key)
      if self.mode in (MODE_CACHE_PASSPHRASE, MODE_AGENT):
        try:
          res = self.sign_uid(key, index)
        except AgentError:
          print 'gpg-agent problems, bailing out!'
          sys.exit(1)
        except PassphraseError:
          print ('The passphrase that worked a moment ago now doesn\'t work.'
                 ' I\'m bailing out!')
          sys.exit(1)
      else:
        res = self.sign_uid_expect(key, index)
      if not res:
        uids[index]['result'] = False
        continue
      uids[index]['result'] = True
      self.export_signed_uid(key, uids[index]['file'])
      if self.encrypt_outfiles:
        self.encrypt_signed_uid(key, uids[index]['file'])
      # Delete the key from our working keyring
      self.nuke_working_keyring()
      self.import_clean_key(key)

    print 'Signed UNencrypted keys: '
    for index in range (1, len(uids)):
      if uids[index]['status'] != 'r' and uids[index]['result']:
        print '  %(email)s: %(file)s' % uids[index]
    if self.encrypt_outfiles:
      print 'Signed encrypted keys: '
      for index in range (1, len(uids)):
        if uids[index]['status'] != 'r' and uids[index]['result']:
          print '  %(email)s: %(file)s.gpg' % uids[index]

    self.clean_clean_key(key)

# END class uids_signer

def main():
  global debug_on

  usage = '%prog [options] -s <signer_keyid> <keyid> [<keyid> ...]'
  parser = OptionParser(usage=usage, version='%%prog %s' % VERSION)
  parser.set_defaults(gpg_path=DEFAULT_GPG_PATH,
                      out_dir=DEFAULT_OUT_DIR,
                      tmp_dir=DEFAULT_TMP_DIR,
                      keyring=DEFAULT_KEYRING,
                      sign_level='3')
  parser.add_option('-a', '--use-agent', action='store_true', dest='agent',
                    help='Use pgp-agent')
  parser.add_option('-b', '--gpg-path', dest='gpg_path', metavar='PATH',
                    help='Path to gpg binary. [default: %default]')
  parser.add_option('-e', '--encrypt-outfiles', action='store_true',
                    dest='encrypt_outfiles',
                    help='Encrypt output files')
  parser.add_option('-d', '--debug', action='store_true', dest='debug',
                    help='Enable debug output.')
  parser.add_option('-l', '--signature-level', dest='sign_level',
                    metavar='LEVEL',
                    help='The level to sign keys at (0-3)')
  parser.add_option('-o', '--out-dir', dest='out_dir', metavar='OUTDIR',
                    help='Directory to put signed keys in. [default: %default]')
  parser.add_option('-p', '--cache_passphrase', action='store_true',
                    dest='cache_passphrase',
                    help='Cache private key passphrase.')
  parser.add_option('-r', '--keyring', dest='keyring', metavar='KEYRING',
                    help='The keyring to use. [default: %default]')
  parser.add_option('-s', '--signer', dest='signer',
                    help='The keyid to sign with (required).')
  parser.add_option('-t', '--tmp-dir', dest='tmp_dir', metavar='TMPDIR',
                    help='Directory to put temporary stuff in. [default:'\
                         ' %default]')

  (options, args) = parser.parse_args()

  print 'Welcome to PIUS, the PGP Individual UID Signer.\n'

  if options.debug == True:
    print 'Setting debug'
    debug_on = True;

  if not options.signer:
    print 'You must specify a keyid to sign with.'
    sys.exit(1)

  if options.cache_passphrase and options.agent:
    print 'You can only select one of -a or -p'
    sys.exit(1)

  mode = MODE_INTERACTIVE
  if options.cache_passphrase:
    mode = MODE_CACHE_PASSPHRASE
  elif options.agent:
    mode = MODE_AGENT

  if not args:
    print 'Keyid required'
    sys.exit(1)

  for dir in (options.tmp_dir, options.out_dir):
    if not os.path.exists(dir):
      os.mkdir(dir, 0700)

  p = uids_signer(options.signer, mode, options.keyring, options.gpg_path,
                  options.tmp_dir, options.out_dir, options.encrypt_outfiles,
                  options.sign_level)

  if options.cache_passphrase:
    print ('WARNING: Using the -p option may have negative security'
      ' implications!')
    while not p.passphrase_confirmed:
      p.get_passphrase()
      if not p.verify_passphrase():
        print 'Sorry, cannot unlock the key with that passphrase, try again.'
  for key in args:
    if not p.check_fingerprint(key):
      continue
    print 'Signing all UIDs on key %s' % key
    p.sign_all_uids(key)

  p.cleanup()

main()
